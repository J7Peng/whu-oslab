# 实验二：页表与内存管理 实验报告



## 一、实验目的

- 理解 **RISC-V 虚拟内存管理机制**（SV39 分级页表结构）。
- 实现 **物理内存分配器**，支持内核区和用户区的分离管理。
- 构建 **内核页表**，并完成内核地址空间到物理地址的映射。
- 熟悉 **虚拟内存相关函数实现流程**：`pmem_alloc/free`、`vm_getpte`、`vm_mappages`、`vm_unmappages`。
- 通过测试验证 **内存管理与页表启用**是否正确。

------

## 二、系统设计部分

### 1. 架构设计说明

- **物理内存管理**
  - 使用链表管理空闲页，每个物理页的前 8 字节存放一个指向下一个空闲页的指针。
  - 将物理内存分为 **内核页区**和**用户页区**，防止用户进程耗尽全部物理页而影响内核安全。
- **虚拟内存管理**
  - 遵循 **SV39 三级页表结构**：39 位虚拟地址，3 级页表，每级 9 位索引。
  - 内核页表（`kernel_pgtbl`）负责映射：
    1. **设备寄存器区**：`0x10000000 ~ 0x20000000`
    2. **内存区**：`0x80000000 ~ 0x80000000+128MB`
  - 页表采用 **直接映射**（VA = PA）方式，简化设计。

------

### 2. 关键数据结构

#### （1）物理页管理

```
typedef struct page_node {
    struct page_node* next;   // 链表指针
} page_node_t;

typedef struct alloc_region {
    uint64 begin;             // 起始物理地址
    uint64 end;               // 终止物理地址
    spinlock_t lk;            // 自旋锁保护
    uint32 allocable;         // 可分配页数
    page_node_t list_head;    // 链表头节点
} alloc_region_t;
```

- **kern_region**：内核物理页区域
- **user_region**：用户物理页区域

#### （2）虚拟内存管理

```
typedef uint64 pte_t;   // 页表项（含物理页号和标志位）
typedef uint64* pgtbl_t; // 顶级页表指针
```

页表项存放物理页号及标志位（R/W/X/V），页表本身也是物理页。

------

### 3. 与 xv6 对比分析

| 方面         | 本实验实现                           | xv6 实现                        |
| ------------ | ------------------------------------ | ------------------------------- |
| 物理内存管理 | 使用链表头插法，分离内核/用户区域    | 使用空闲链表，但不区分内核/用户 |
| 页表结构     | RISC-V SV39 三级页表                 | x86 单级页表（或简化多级）      |
| 内核页表     | VA=PA 直接映射硬件区和内存区         | 同样建立内核恒等映射            |
| 设计目标     | 防止用户进程耗尽物理页、支持并发安全 | 重点在简单支持多进程内存管理    |

------

### 4. 设计决策理由

- **内核/用户页区分**：避免恶意用户耗尽内存。
- **链表头插法**：实现简单，`alloc`/`free` 均为 O(1)。
- **直接映射**：减少调试难度，保证内核访问稳定。
- **三级页表**：符合 RISC-V SV39 规范，节省空间，利于扩展。

------

## 三、实验过程部分

### 1. 实现步骤记录

1. **物理内存管理**
   - 定义 `page_node_t` 和 `alloc_region_t`。
   - 实现 `pmem_init`：构建内核区与用户区链表。
   - 实现 `pmem_alloc` / `pmem_free`：页分配与回收。
2. **虚拟内存管理**
   - 实现 `vm_getpte`：逐级遍历/分配页表。
   - 实现 `vm_mappages`：建立 VA→PA 映射。
   - 实现 `vm_unmappages`：解除映射并可选释放物理页。
   - 实现 `vm_print`：打印页表映射，辅助调试。
3. **内核页表构建**
   - 在 `kvm_init` 中分配 `kernel_pgtbl`。
   - 映射硬件寄存器区与内存区。
   - `kvm_inithart` 写入 `satp` 并执行 `sfence_vma` 使能页表。

------

### 2. 问题与解决方案

- **问题1**：初始链表挂接时出现 `allocable` 计数错误。
  - **解决**：检查循环边界条件，确保 `PGROUNDUP(lo)` 到 `PGROUNDDOWN(hi)` 的区间正确。
- **问题2**：`vm_unmappages` 释放时出现 panic。
  - **解决**：增加 `PTE_CHECK` 判断，区分叶子 PTE 与中间节点。
- **问题3**：页表未生效，TLB 未更新。
  - **解决**：在 `kvm_inithart` 中加入 `sfence_vma()`，确保刷新 TLB。

------

### 3. 源码理解总结

- **`pmem.c`** 管理物理页，采用链表头插法。
- **`vmem.c`** 实现虚拟内存的核心操作，包括页表查询、建立、解除映射。
- **`kvm.c`** 构建并启用内核页表，是虚拟内存启用的关键步骤。
- **整体设计思路**：内核通过 `pmem_alloc` 获取物理页作为页表，`vm_mappages` 完成虚拟地址到物理地址的绑定，最终由 `satp` 寄存器驱动 MMU 翻译。

------

## 四、测试验证部分

### 1. 功能测试方法

- 在 `kvm_init` 后调用 `vm_print`，检查是否正确打印出：
  - `VA=0x10000000 -> PA=0x10000000 flags=...`
  - `VA=0x80000000 -> PA=0x80000000 flags=...`
- 在用户态申请/释放物理页，检查内存状态变化。
- 在 `unmappages` 后尝试访问，确认 panic 触发。

### 2. 功能测试结果

- 内核成功建立页表并写入 `satp`，系统正常运行。
- `pmem_alloc`/`pmem_free` 行为正确，`allocable` 值与预期一致。![image-20250930201637259](C:\Users\34302\AppData\Roaming\Typora\typora-user-images\image-20250930201637259.png)
- `vm_mappages` 映射正确，`vm_unmappages` 能释放物理页。![379fda75d18878fc7016bc5092549897](D:\34302\Documents\Tencent Files\Tencent Files\3430227607\nt_qq\nt_data\Pic\2025-09\Ori\379fda75d18878fc7016bc5092549897.png)
- 页表启用后，系统仍能输出调试信息，说明地址翻译正确。

------

## 五、结论

- 本实验完成了 **RISC-V 平台物理内存与虚拟内存管理的基本实现**。
- 理解了 **内核物理页分配**与**三级页表映射**的原理。
- 学习了如何通过 **内核页表初始化与 satp 切换**启用虚拟内存。
- 实验结果表明，系统能够正确运行，达到了实验目标。