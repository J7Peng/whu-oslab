## 系统设计部分

### 架构设计说明

本实验参考 xv6 的 RISC-V 启动机制，在 QEMU 的 `virt` 平台上实现一个最小内核。其基本流程如下：

1. **汇编入口（entry.S）**
   - 设置栈指针
   - 清零 BSS 段
   - 跳转到 C 主函数
2. **C 语言主函数（main.c）**
   - 初始化 UART 串口
   - 输出字符串 `"Hello OS!"`
   - 进入死循环，防止程序退出

系统运行在 **M 模式（Machine Mode）**，没有引入复杂的内存管理与进程调度，仅关注裸机启动与基本输出。

### 关键数据结构

由于目标是最小系统，关键数据结构仅包括：

- **UART 基地址和寄存器定义**

  ```
  #define UART_BASE 0x10000000L
  #define RHR 0     // 接收寄存器
  #define THR 0     // 发送寄存器
  #define LSR 5     // 状态寄存器
  ```

- **BSS 段标识符**（由链接脚本定义）

  ```
  .bss : {
    _bss_start = .;
    *(.bss .bss.*)
    _bss_end = .;
  }
  ```

### 与 xv6 对比分析

- **简化点**
  - xv6 有多核初始化逻辑，本实验只需单核/简单多核
  - xv6 初始化了内存管理（页表、虚拟地址），本实验直接裸机物理地址
  - xv6 支持 trap/中断，本实验不涉及
- **保留点**
  - 栈初始化
  - BSS 段清零
  - 串口输出

### 设计决策理由

- **栈设计**：程序一旦进入 C 函数就必须有可靠栈空间，否则局部变量、函数调用无法使用。
- **BSS 清零**：C 语言标准要求未初始化的全局变量默认为 0，否则全局变量值不确定。
- **UART 输出**：验证程序能正确运行的最直观方式。
- **死循环**：防止程序执行到末尾引发异常重启。

------

## 实验过程部分

### 实现步骤记录

1. 编写 `entry.S`：设置栈 → 清零 BSS → 跳转 `main`。

2. 编写 `kernel.ld`：指定入口 `_start`，将代码段放在 `0x80000000`。

3. 编写 `uart.c`：实现 `uart_putc` 和 `uart_puts`。

4. 编写 `main.c`：调用初始化函数，输出 `"Hello OS!"`。

5. 使用 QEMU 运行：

   ```
   qemu-system-riscv64 -machine virt -nographic -kernel kernel.elf
   ```

### 问题与解决方案

- **无输出问题**：检查发现入口地址没有对齐到 `0x80000000` → 修改链接脚本。
- **乱码问题**：未正确初始化 UART 波特率 → 参考 xv6 的 `uart.c` 修复。
- **多核启动输出丢失**：共享 UART 时未加锁 → 引入自旋锁解决。

### 源码理解总结

- xv6 的启动流程比实验更复杂，本实验只保留了**最小启动必需步骤**。
- 链接脚本和启动汇编的作用是确保 C 代码运行环境正确。

------

## 测试验证部分

### 功能测试结果

- 启动后正确输出：

  ```
  Hello OS!
  ```

### 性能数据

- 程序大小约 10 KB
- 启动耗时 < 0.1s（QEMU 环境）

### 异常测试

- 刻意删除 BSS 清零代码，结果全局变量值不确定，验证了清零必要性。
- 刻意将入口点改错地址，程序卡死无输出，验证了 `ENTRY(_start)` 必须正确设置。

### 运行截图

QEMU 输出截图（或录屏）：

![image-20250919174358463](C:\Users\34302\AppData\Roaming\Typora\typora-user-images\image-20250919174358463.png)

------

## 思考题回答

1. **启动栈设计**
   - 栈大小通常给 4KB 或 8KB，足够支持函数嵌套。
   - 栈溢出会覆盖数据，引发不可预期错误。可通过保护页检测溢出，但本实验未实现。
2. **BSS 清零**
   - 若不清零，全局变量可能有随机值。
   - 最小实验可省略，但会违反 C 语言标准。
3. **与 xv6 对比**
   - 简化点：无页表、无 trap/中断、无文件系统。
   - 这些简化在真正多任务 OS 中会成为问题。
4. **错误处理**
   - 若 UART 初始化失败，系统应输出错误码（例如直接写内存指示灯）。
   - 最小系统可以通过串口输出 `'E'` 来标记错误。